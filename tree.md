### 深度与高度问题
#### 深度是从根节点数到它的叶节点,高度是从叶节点数到它的根节点


1. 平衡二叉树，如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树

在深度问题上，递归处理时候采用后序遍历，先递归左右叶节点，保证处理每个叶节点的时候，能拿到当前叶节点的深度


#### 高度和深度是相反的表示,深度是从上到下数的,而高度是从下往上数
同理，在高度问题上，递归处理


### 查找最近公共祖先

* “对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）
* 所有节点的值都是唯一的。  p、q 为不同节点且均存在于给定的二叉搜索树中

一般是对于一颗二叉树，提供 p,q 两个节点，要求从树中找到这两个节点的最近公共祖先

该公共祖先node满足： node = (node-left && node-right) || ( (node === p || node ===q) && (node-left || node-right) )
怎么理解呢：
(node-left && node-right)：即 p,q 分别位于当前node节点的左右子树中
(node === p || node ===q) && (node-left || node-right)： 即当前节点是 p,q 的某一个节点，且 p,q 的另一个节点是该节点的子树的一部分

1. 二叉树查找最近公共祖先

二叉树查找公共祖先，利用上面提到的 公共组件node满足的前提 node = (node-left && node-right) || ( (node === p || node ===q) && (node-left || node-right) )

利用后序遍历的递归模型，因为是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到。

在后序遍历的处理中，默认 root === null 时返回 false，来保证前提条件被满足


2. 二叉搜索树查找最近公共祖先

与二叉树查找最近公共祖先不同，二叉搜索树由于本身存在：其中序遍历是单调递增的特性；只需要在递归中不停切换节点分支，直到遇到满足条件的分支

(1) root.val > p.val && root.val > q.val  -> 此时调整递归子树切到 root.left 继续
(2) root.val < p.val && root.val < q.val  -> 此时调整递归子树切到 root.right 继续
(3) 当条件(1)和(2)均不满足，此时存在的情况如下：
a: root.val === p.val || root.val === q.val
   root.val === p.val && root.val !== q.val 
   root.val !== p.val && root.val === q.val
b: root.val > p.val && root.val < q.val
c: root.val < p.val && root.val > q.val

以上所有情况，都符合 p, q 是在一颗子树的条件，所以此时的 root，即我们找到的最近公共祖先

3. 扩展

在查找最近公共祖先的问题上，可以利用链表，将每个节点都指向父节点，当找到 p,q 节点时，从两个链表中，找到第一个相交的节点，即最近公共祖先。


### 最小高度树
给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树
收集信息：
1. 有序数组，升序排列
2. 元素各不相同
3. 创建二叉搜索树，且保证高度最小

分析：
1. 二叉搜索树：中序遍历是递增的有序数列
2. 结合数组是有序且升序排序，要保证高度最小，那么就要保证左右子树尽量平衡
3. 取中点做root节点，保证左右子树平衡

`
那么意味着每次构建的根和叶节点的root节点，都从mid中点构建
递归如何解决呢：
1. 先找到创建的函数，获取mid构建root节点, 那么需要以中点为分界传入左右边界，left - right
2. 每次对边界进行移动，左子树对应 head-mid, 右子树为 mid-tail
3. 递归边界：当 left > right，结束递归

`